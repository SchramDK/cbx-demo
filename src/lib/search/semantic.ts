

/*
  Semantic search helpers (MVP)
  ------------------------------------------------
  - Loads a static AI index generated by scripts/ai/index-assets.ts
  - Computes cosine similarity between query embedding and asset embeddings
  - Returns top-K semantic matches with scores

  This file is intentionally dependency-free so it can run on the client
  (for demo) or server. Swap the embed() impl later.
*/

export type SemanticAsset = {
  id: string;
  title: string;
  category?: string;
  preview: string;
  document: string;
  embedding: number[];
};

export type SemanticResult = {
  id: string;
  score: number; // cosine similarity
};

// -----------------------------
// Math helpers
// -----------------------------

export function cosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length || a.length === 0) return 0;
  let dot = 0;
  let na = 0;
  let nb = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    na += a[i] * a[i];
    nb += b[i] * b[i];
  }
  const denom = Math.sqrt(na) * Math.sqrt(nb);
  return denom === 0 ? 0 : dot / denom;
}

// -----------------------------
// Embedding (stub for demo)
// Replace with real model later
// -----------------------------

export async function embedQuery(text: string): Promise<number[]> {
  // Deterministic stub: mirrors the index script so scores are stable
  const hash = Array.from(text)
    .reduce((acc, c) => acc + c.charCodeAt(0), 0);
  return Array.from({ length: 64 }, (_, i) => Math.sin(hash + i));
}

// -----------------------------
// Load index
// -----------------------------

let cachedIndex: SemanticAsset[] | null = null;

export async function loadSemanticIndex(): Promise<SemanticAsset[]> {
  if (cachedIndex) return cachedIndex;
  const res = await fetch('/demo/ai/stock-index.json');
  if (!res.ok) throw new Error('Failed to load semantic index');
  cachedIndex = await res.json();
  return cachedIndex!;
}

// -----------------------------
// Search
// -----------------------------

export async function semanticSearch(
  query: string,
  opts?: { topK?: number; minScore?: number }
): Promise<SemanticResult[]> {
  const topK = opts?.topK ?? 40;
  const minScore = opts?.minScore ?? 0.15;

  const [index, qv] = await Promise.all([
    loadSemanticIndex(),
    embedQuery(query),
  ]);

  const scored = index
    .map((a) => ({
      id: a.id,
      score: cosineSimilarity(qv, a.embedding),
    }))
    .filter((r) => r.score >= minScore)
    .sort((a, b) => b.score - a.score)
    .slice(0, topK);

  return scored;
}